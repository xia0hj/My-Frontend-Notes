# 算法

## 二叉树的非递归遍历模板

```js
// 前序遍历：中->左->右
var preorderTraversal = function(root) {
  const result = []
  const stack = []
  if(root) stack.push(root) // 根节点第一个入栈
  while ( stack.length > 0 ) {
    const cur = stack.pop()
    if( cur !== null ) {
      // 入栈顺序与遍历顺序相反：右->左->中
      // 不同的遍历顺序只需调整此处的入栈顺序即可
      if(cur.right !== null) stack.push(cur.right)
      if(cur.left !== null) stack.push(cur.left)
      // 中节点入栈后要再入栈null作为标记
      stack.push(cur)
      stack.push(null)
    } else {
      result.push(stack.pop().val)
    }
  }
  return result
};
```

## 约瑟夫环

```js
// n=当前有多少人, k=报数报到k的人退出(每轮都不会变)
// fn(n,k) = ( fn(n-1, k) + k ) % n = 当前有n人的轮次获胜者的下标
let winner = 0 // 最后一轮剩下一个人，获胜者是0
// 从剩下2个人开始反推
for(let i=2; i<=n; i++){
  winner = (winner+k)%i
}
return winner+1 // 前面计算是从0开始的下标，结果要加1
```
