# 面试前准备

1. 声音：手机静音，电脑不要外放  
2. 手机上用浏览器打开笔记 md 转换成的 html，记得修改 html 的名字为中文方便区分  
3. 答不上的不要百度，千万不要假装思考，等一会流利地回答正确答案，一下就露馅了
4. 观察一下摄像头中能不能看到自己的眼镜反光，照出手机
5. 要尽量把题目都放在同一个文件中，不然在浏览器中切来切去会乱的
6. 振作起来，想想华为od二面被抓到作弊时的心情

# JavaScript

## 1. js 的数据类型

1. 基本数据类型有 String、Number、Boolean、Undefined、Null，还有 es6 新增的 Symbol，<font color="orange">参考 2</font>。
2. 引用类型有对象、数组、函数 3 种。
3. 区别是存储位置不同：
   1. 基本数据类型直接存储在栈中的简单数据段，因为它占据空间小，而且会频繁使用。
   2. 引用类型保存在堆中，因为占据空间大，且大小不固定；在栈中保存了指针指向它在堆中的地址。

## 2. Symbol

1. Symbol 表示一个独一无二的值，Symbol() 的参数只是描述，即使描述相同，Symbol 值也是不相等的；而且 Symbol 不是对象。
2. 用途：
   1. 定义对象的唯一属性名：如果要给对象新增一个属性，用 Symbol 当作属性名，可以保证不会属性名重复，避免原有属性被覆盖。
   2. 私有属性：用 Symbol 作为对象的属性名，且不对外暴露，这样使用者无法在外部创建出一个相同的 Symbol。

## 3. es6 的新特性

1. const、let：
   1. 为了解决 var 的 3 个问题：变量提升、重复声明、没有块级作用域只能用函数作用域。
   2. const、let 存在暂时性死区，等到声明那一行代码出现后才能使用该变量，且不能重复声明
   3. const、let 支持大括号包起来的块级作用域，var 只能借助函数包起来
2. 模板字符串：用反引号，里面可以用 $\{ \} 放 js 表达式，会将返回值放到字符串中，并且会保留换行和空格
3. 剩余参数：在参数前面加 3 个点表示，只能放在最后面，把剩余没有对应形参的参数放到一个数组中，<font color="orange">参考 17</font>
4. Set 和 Map
5. 箭头函数：普通函数的 this 是可变的，而箭头函数没有自己的 this，在箭头函数中使用 this 实际是上一层作用域中的 this，<font color="orange">参考 6</font>。
6. Generator 函数：支持暂停分段执行的函数，在 function 和函数名中间加一个星号，在函数体里面用 yield 将函数分段，调用该函数返回一个控制器，每次调用 next() 方法都会执行到 yield；可以用来将异步代码写成同步的形式，将异步后要执行的代码放在下一个分段，在异步任务中调用 next() 去执行下一段
7. Promise：用来包装一个异步调用，目的是解决层层嵌套的异步回调函数
8. async / await：用来写异步代码的关键字，async 函数会将 return 值通过 Promise.resolve() 方法包装成 Promise 对象再返回；await 后跟一个 Promise 对象，那么就会阻塞后续的代码，直到 Promise resolve 之后再执行。
9. class：生成实例时必须用 new，实例会继承类中定义的属性，类之间也能通过 extends 关键字继承
10. 模块化：<font color="orange">参考 9</font>

## 4. var、let、const 之间的区别

1. 块级作用域：var 声明的变量不支持大括号表示的块级作用域，只能用函数作用域代替，而 const 和 let 支持。
2. 变量提升：var 声明的变量会提升到所有代码执行之前被声明，但不会赋值；let 和 const 存在暂时性死区，等到声明那一行代码出现后才能使用该变量。
3. 重复声明：var 可以，const 和 let 不允许。
4. const 声明同时必须赋值，此后不能修改；const 对象不能修改引用地址，但可以修改对象中的值。

## 5. 原型、原型链

1. 每个构造函数内部都有一个 prototype 属性值，它是一个对象，包含了一些共享的属性和方法，由构造函数创建的对象都会共享这些属性。
2. 使用构造函数创建的对象，内部有 \_\_proto\_\_ 指针指向构造函数的 prototype 来让我们访问原型，也可以使用 Object.getPrototypeOf() 方法来获取原型。
3. 当我们访问一个对象的属性时，如果对象内部不存在这个属性，就会到它的原型对象上去寻找属性，原型对象又会有自己的原型，这样一直找下去就是原型链。
4. 原型链的尽头一般是 Object.prototype，我们新建的对象可以用到它上面的 toString 等常用方法。
5. Object.prototype 的原型是 null，null 表示空对象，用 null 来表示尽头比较合理。

## 6. js this 指向

1. 普通函数直接调用：指向 window。
2. 普通函数作为对象方法调用：指向所属对象。
3. 通过 new 来调用构造函数：指向创建的新对象
4. 箭头函数：没有自己的 this，会使用外层的 this

## 7. Map 和 Object 的区别

1. Object 属性的键只能是字符串或者 Symbol；Map 的键可以是任意值。
2. Map 的键值对是有序的，按照插入顺序；而 Object 的属性在遍历时是无序的。
3. Object 有原型对象，有的键是默认存在的，可能会与自定义的键重复；Map 就不会有默认的键
4. Map.size 属性可以获取键值对的数量；而 Object 需要通过 Object.keys(obj) 方法来获取键的数组，从而得到键值对数量。

## 8. 遍历

1. for(let i=0)：最基础的遍历数组的方法。
2. forEach()：回调函数有 3 个参数：当前元素、下标、数组；无法使用 break 跳出循环，在回调中 return 相当于普通遍历的 continue，不能用于对象遍历。
3. for of：遍历数组的每个元素，不支持遍历对象，只能用于遍历实现了 Iterator 接口的数据类型
4. for in：遍历数组的下标，一般不会用来遍历数组；遍历对象的 key，但是会遍历原型上的 key，需要用 obj.hasOwnProperty() 来判断 key 是否属于当前对象
5. Object.keys()、values()、entries()：分别返回对象的 key 数组、属性值数组、包含键值对的二维数组

## 9. js 模块化的 4 种方案

1. CommonJS：require 引入模块，module.exports 暴露模块，它是同步引入模块的，所以不适用于浏览器端，因为浏览器请求是异步的。
2. AMD：这种方案会异步加载模块，require.js 实现了 AMD 规范。
3. CMD：也是异步加载的，与 AMD 的区别是：AMD 加载模块完成后就会执行，所有模块执行完毕后才会执行主要逻辑；而 CMD 加载后不会执行，在主要逻辑中遇到 require 语句才会执行模块。
4. ES6 Module：用 import 和 export 的形式来导入导出，与 CommonJS 的区别：CommonJS 加载模块后生成一个对象，然后从这个对象上取值和方法；es6 模块生成一个引用，运行时再根据这个引用去模块中取值

## 10. 如何判断 js 变量的类型

1. typeof
2. instanceof：用来检查右侧构造函数的原型对象是否出现在左侧实例对象的原型链上。
3. constructor：构造函数的原型对象上有 constructor 属性指向该函数，可访问对象的原型上的 constructor，但这种方法不能检查 null 和 undefined，它们没有原型。
4. Object.prototype.toString.call()：Object 的原型上的 toString() 方法，返回内部属性 \[\[class\]\]，一般是 \[object Number\] 这种样式的字符串。

## 11. == 和 === 的区别

1. == 比较基本类型，如果类型不同，会先强制转换后再比较。
2. === 比较基本类型，先比较类型再比较值，如果类型不同就返回 false，不进行转换。
3. 在比较引用类型时，== 和 === 都是比较地址。

## 12. use strict 严格模式

1. use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制，目的是消除代码中一些不合理的使用方式。
2. 严格模式的限制：
   1. 不允许使用未声明的变量；
   2. 不允许用 delete 关键字删除变量；
   3. 不允许变量重名；
   4. 禁止 this 关键字指向全局对象；
   5. ...

## 13. undefined 和 null 的区别

1. undefined 表示未定义，变量声明后但没有赋值就是 undefined；null 表示空对象，一般是赋值给对象作为初始值。
2. 用 typeof 判断，null = 'object'，undefined = 'undefined'。
3. 转换成 Number 类型，null = 0，undefined = NaN。
4. null 是保留的关键字，而 undefined 不是。

## 14. window.isNaN() 和 Number.isNaN() 的区别

1. window.isNaN() 会尝试去将参数的类型转换成数字，如果不能被转换成数字都返回 true；所以，只是判断参数能否转换成数组，不会严格判断 NaN。
2. Number.isNaN() 会先判断参数的类型是不是 Number，如果不是 Number 都返回 false；NaN 表示不合法的数字，如 -1 开方。

## 15. 其他类型隐式转 Boolean

1. undefined
2. null
3. 0
4. NaN
5. ""
6. 其余都转换成 true

## 16. new 操作符做了什么及其代码实现

1. 首先创建一个空对象，并将空对象的原型设为构造函数的 prototype。
2. 让构造函数的 this 指向这个新对象，然后执行。
3. 如果构造函数返回的是引用类型，就直接将它返回；否则返回新对象。

```js
function newOperation(constructor, ...args){
   if(typeof constructor !== 'function'){
      throw new TypeError('constructor is not a function')
   }
   const obj = Object.create(constructor.prototype) // obj.__proto__ = constructor.prototype
   const fnReturn = constructor.apply(obj, args)
   if(typeof fnReturn === 'object' || typeof fnReturn === 'function'){
      return fnReturn
   }else{
      return obj
   }
}
// 自测
function fn(msg){this.msg=msg}
const a = new fn('aaa')
const b = newOperation(fn, 'bbb')
```

## 17. arguments 对象和剩余参数 ...args 的区别

1. arguments 对象包含所有参数，剩余参数只能放在最后且只包含没有对应形参的参数
2. arguments 对象不是数组，不能直接使用数组的方法，需要这样才能用数组的方法 `Array.prototype.push.call(arguments, newVal)`
3. 剩余参数是真正的数组

## 18. 函数的 call，apply，bind 区别

1. 它们都是用来重定义this对象的。
2. call 和 apply 都会执行该函数并将 this 指向第一个参数的对象，区别是apply 的剩余参数开始要放到一个数组中，而 call 的参数直接用逗号分隔
3. bind 的参数跟 call 一样用逗号分隔，但它返回的是调整了 this 指向的函数，并没有执行。

## 19. 闭包是指有权访问另一个函数作用域中的变量的函数

1. 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式是在函数中创建另一个函数，通过这个函数访问到当前函数中的局部变量
2. 用途：
   1. 能在外部通过闭包函数去访问函数内部的变量，可以用这种方法来创建私有变量。
   2. 使已经运行结束的函数上下文中的变量继续保留在内存中，因为闭包函数保留了对这个变量的引用，所以不会被回收。

## js 异步

## Promise

# vue

## prevent 阻止冒泡

# CSS

## 水平居中

# HTML && 浏览器 && 计算机网络

## 跨域

# 工具

## webpack 中 loader 和 plugin 的区别

# React

## 常用 hook