# HTML && 浏览器

## HTML5 的新特性

1. 新增的有：
   1. 绘画用的 canvas
   2. 播放视频和音频的 video 和 audio
   3. localStorage 用于本地存储，浏览器关闭后数据不丢失
   4. sessionStorage 也能存储，但浏览器关闭后自动删除
   5. 新的技术 web worker
2. 移除的有一些纯用于表现的元素：big、center(文本居中)、u(下划线)

## 常见浏览器及其内核

1. IE：Trident 内核
2. Chrome：Chromium 内核，发音克若米恩
3. FireFox：Gecko 内核
4. Safari：Webkit 内核

## 浏览器输入网址到显示网页的过程

1. 查询 DNS，获取域名对应的 IP 地址。首先查浏览器 DNS 缓存，然后查系统 DNS 缓存和 HOST 文件，最后去本地域名服务器进行查找，服务器会从根域名服务器开始逐级查找；
2. 获取 IP 地址后，进行 TCP/IP 三次握手；
3. 成功建立连接后，浏览器发送请求
4. 服务器处理请求，随后返回响应报文
5. 浏览器解析渲染页面

## 浏览器渲染页面的过程

1. 首先解析接收到的 HTML 文件，转化成 DOM 树
2. 然后解析 CSS，生成 CSSOM 规则树
3. 根据 DOM 树和 CSSOM 树合并成渲染树，渲染树包含了要显示的节点以及样式信息
4. 根据渲染树来进行布局，这一阶段浏览器就是要搞清楚各个节点在页面中的位置和大小，也叫做回流、重排
5. 最后就是绘制阶段，遍历渲染树将各个节点显示在屏幕上

## 回流/重排 和 重绘

1. 回流/重排：当渲染树的某些元素因为尺寸、位置等属性发生改变，影响到布局，导致要重新去构建那一部分受影响的渲染树
2. 重绘：当渲染树的某些元素更新了一些不影响布局的属性，比如说改了颜色，浏览器就会跳过布局阶段，直接重新绘制元素
3. 回流一定会发生重绘，重绘不一定会回流，回流所需成本要比重绘高
4. 回流的产生：
   1. 元素大小改变：内外边距、边框、宽高等等
   2. 内容变化：用户在 input 输入框里输入文字
   3. 浏览器窗口大小发生改变
   4. 添加或删除可见的 DOM 元素
   5. 设置 style 属性
   6. 调用 getComputedStyle() 也会引起回流，为了获取到最新准确的数据
5. 减少回流的方法：
   1. 不要一条一条地去修改 style 属性，可以先预定义好 class 样式，然后修改 DOM 的 class
   2. 避免在循环中读取 DOM 的某些会引起回流的属性，例如 offsetWidth、offsetHeight，应该在循环之前先保存起来
   3. 不要用 table 布局，因为 table 中某个元素一旦触发回流会造成整个 table 的重新布局

## 搜索引擎优化 SEO

1. 用好 HTML 的语义化标签
2. 重要内容 HTML 代码放前面；搜索引擎抓取 HTML 是从上到下，有的搜索引擎抓取长度有限制，放前面保证重要内容被抓取
3. 重要内容不用 js 来输出，爬虫不会执行 js 去获取内容
4. 少用 iframe，搜索引擎不抓取 iframe 的内容
5. 非装饰性的图片加 alt

## 二维码原理

1. 用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应；
2. 当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示；
3. 当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页

## 浏览器或 HTTP 的缓存机制

1. 响应头的 Cache-Control 字段控制强制缓存，假如浏览器判断缓存没有过期，那么无需向服务器发送这个资源请求了，可以直接使用该缓存，属性值如下：
   1. max-age=3600：缓存有效时间，单位毫秒
   2. no-store：禁止缓存，涉及用户的敏感信息时应该开启
   3. no-cache：使用协商缓存，与 no-store 互斥
   4. public：表示该资源可以被中间层的代理服务器缓存
   5. private：表示该资源只能由浏览器缓存，禁止中间层缓存，与 public 互斥
2. 协商缓存与强制缓存不同，每次使用缓存前都要向服务器发送请求，由服务器来判断缓存是否有效，不能浏览器自己来判断；服务器返回资源文件时，可以在响应头中带上资源标识 Last-Modified（资源文件上次修改时间）和 ETag（资源文件唯一标识字符串），浏览器会记录下来这两个值；下次发送请求时，会在请求头中通过 If-Modified-Since 和 If-None-Match 带上这两个值，由服务器判断浏览器的缓存资源是否过期，过期则返回 200 状态及新的资源文件，未过期则只返回 304 状态码；对比 Last-Modified 和 ETag，优先使用 ETag，因为 Last-Modified 只能精确到秒
3. 相关博客文章：[HTTP缓存——强制缓存和协商缓存](https://blog.csdn.net/weixin_52148548/article/details/124843301)

## 请求头中的 ETag 生成

1. nginx 的 etag 由 Last-Modified 和 content-length 两个字段值转换成十六进制组合而成。
2. etag 发生改变不代表资源文件一定发生改变，假如重新生成了相同的资源文件，导致 Last-Modified 发生变化而 content-length 不变，则生成 etag 也变了，但文件内容实则没有变化。

## 前端登录流程

1. 当用户点击登录时，前端带着用户名和密码去调用后端接口
2. 后端校验密码，验证失败返回错误信息，验证成功返回 token
3. 前端将 token 存储到 localStorage 中，然后跳转页面登录成功
4. 前端每次访问需要登录状态的页面时都检查 token 是否存在，想后端发送请求时在请求头带上 token
