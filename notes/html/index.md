# HTML && 浏览器

## HTML5 的新特性

1. 新增的有：
   1. 绘画用的 canvas
   2. 播放视频和音频的 video 和 audio
   3. localStorage 用于本地存储，浏览器关闭后数据不丢失
   4. sessionStorage 也能存储，但浏览器关闭后自动删除
   5. 新的技术 web worker
2. 移除的有一些纯用于表现的元素：big、center(文本居中)、u(下划线)

## 常见浏览器及其内核

1. IE：Trident 内核
2. Chrome：Chromium 内核，发音克若米恩
3. FireFox：Gecko 内核
4. Safari：Webkit 内核

## 浏览器输入网址到显示网页的过程

1. 查询 DNS，获取域名对应的 IP 地址。首先查浏览器 DNS 缓存，然后查系统 DNS 缓存和 HOST 文件，最后去本地域名服务器进行查找，服务器会从根域名服务器开始逐级查找；
2. 获取 IP 地址后，进行 TCP/IP 三次握手；
3. 成功建立连接后，浏览器发送请求
4. 服务器处理请求，随后返回响应报文
5. 浏览器解析渲染页面

## 浏览器渲染页面的过程

1. 首先解析接收到的 HTML 文件，转化成 DOM 树
2. 然后解析 CSS，生成 CSSOM 规则树
3. 根据 DOM 树和 CSSOM 树合并成渲染树，渲染树包含了要显示的节点以及样式信息
4. 根据渲染树来进行布局，这一阶段浏览器就是要搞清楚各个节点在页面中的位置和大小，也叫做回流、重排
5. 最后就是绘制阶段，遍历渲染树将各个节点显示在屏幕上

## 回流/重排 和 重绘

1. 回流/重排：当渲染树的某些元素因为尺寸、位置等属性发生改变，影响到布局，导致要重新去构建那一部分受影响的渲染树
2. 重绘：当渲染树的某些元素更新了一些不影响布局的属性，比如说改了颜色，浏览器就会跳过布局阶段，直接重新绘制元素
3. 回流一定会发生重绘，重绘不一定会回流，回流所需成本要比重绘高
4. 回流的产生：
   1. 元素大小改变：内外边距、边框、宽高等等
   2. 内容变化：用户在 input 输入框里输入文字
   3. 浏览器窗口大小发生改变
   4. 添加或删除可见的 DOM 元素
   5. 设置 style 属性
   6. 调用 getComputedStyle() 也会引起回流，为了获取到最新准确的数据
5. 减少回流的方法：
   1. 不要一条一条地去修改 style 属性，可以先预定义好 class 样式，然后修改 DOM 的 class
   2. 避免在循环中读取 DOM 的某些会引起回流的属性，例如 offsetWidth、offsetHeight，应该在循环之前先保存起来
   3. 不要用 table 布局，因为 table 中某个元素一旦触发回流会造成整个 table 的重新布局

## 搜索引擎优化 SEO

1. 用好 HTML 的语义化标签
2. 重要内容 HTML 代码放前面；搜索引擎抓取 HTML 是从上到下，有的搜索引擎抓取长度有限制，放前面保证重要内容被抓取
3. 重要内容不用 js 来输出，爬虫不会执行 js 去获取内容
4. 少用 iframe，搜索引擎不抓取 iframe 的内容
5. 非装饰性的图片加 alt

## 二维码原理

1. 用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应；
2. 当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示；
3. 当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页

## 浏览器或 HTTP 的缓存机制

1. 响应头的 Cache-Control 字段控制强制缓存，假如浏览器判断缓存没有过期，那么无需向服务器发送这个资源请求了，可以直接使用该缓存，属性值如下：
   1. max-age=3600：缓存有效时间，单位毫秒
   2. no-store：禁止缓存，涉及用户的敏感信息时应该开启
   3. no-cache：使用协商缓存，与 no-store 互斥
   4. public：表示该资源可以被中间层的代理服务器缓存
   5. private：表示该资源只能由浏览器缓存，禁止中间层缓存，与 public 互斥
2. 协商缓存与强制缓存不同，每次使用缓存前都要向服务器发送请求，由服务器来判断缓存是否有效，不能浏览器自己来判断；服务器返回资源文件时，可以在响应头中带上资源标识 Last-Modified（资源文件上次修改时间）和 ETag（资源文件唯一标识字符串），浏览器会记录下来这两个值；下次发送请求时，会在请求头中通过 If-Modified-Since 和 If-None-Match 带上这两个值，由服务器判断浏览器的缓存资源是否过期，过期则返回 200 状态及新的资源文件，未过期则只返回 304 状态码；对比 Last-Modified 和 ETag，优先使用 ETag，因为 Last-Modified 只能精确到秒
3. 相关博客文章：[HTTP缓存——强制缓存和协商缓存](https://blog.csdn.net/weixin_52148548/article/details/124843301)

## 请求头中的 ETag 生成

1. nginx 的 etag 由 Last-Modified 和 content-length 两个字段值转换成十六进制组合而成。
2. etag 发生改变不代表资源文件一定发生改变，假如重新生成了相同的资源文件，导致 Last-Modified 发生变化而 content-length 不变，则生成 etag 也变了，但文件内容实则没有变化。

## 前端登录流程

1. 当用户点击登录时，前端带着用户名和密码去调用后端接口
2. 后端校验密码，验证失败返回错误信息，验证成功返回 token
3. 前端将 token 存储到 localStorage 中，然后跳转页面登录成功
4. 前端每次访问需要登录状态的页面时都检查 token 是否存在，想后端发送请求时在请求头带上 token

## 如何解决跨域问题

1. 解决跨域的方法我们可以根据我们想要实现的目的来划分。
2. 首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决，将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。
3. 如果是想要解决不同跨域窗口间的通信问题，可以使用 postMessage，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。
4. 如果是像解决 ajax 无法提交跨域请求的问题
   1. 可以使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。
   2. 使用 CORS 的方式，CORS 是一个 W3C 标准，全称是"跨域资源共享"。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。
   3. 使用 websocket 协议，这个协议没有同源限制。
   4. 使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。

## HTTP 报文格式

1. 请求报文：请求行（请求方法、URL 等信息）、请求头、header 与 body 之间的空行、请求内容实体
2. 响应报文：状态行（状态码）、响应头、header 与 body 之间的空行、响应内容实体

## HTTP 状态码

1. 1xx=协议处理的中间状态,101更换协议
2. 2xx=成功,200成功,204成功但不返回实体内容,206成功处理部分请求,用于断点续传和分块下载
3. 3xx=重定向,301永久重定向,302临时重定向
4. 4xx=请求报文有误,400请求报文语法错误,403服务器拒绝,404在服务器上找不到资源,
5. 5xx=服务器端发生错误,500服务器内部错误,502网关错误,503服务器过载

## 请求方法 GET 和 POST 的区别

1. 语义：GET用于请求资源，POST用于提交数据
2. 缓存：GET请求会被浏览器主动缓存下来留下历史记录，POST不会
3. 编码：GET只能用URL编码，只能接收ASCII字符，POST没有限制
4. 参数：GET的参数放在URL中，不安全，POST的参数放在请求体body中
5. 幂等性：GET具有幂等性，没有副作用；而POST不是

